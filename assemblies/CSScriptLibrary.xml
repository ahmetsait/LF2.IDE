<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CSScriptLibrary</name>
    </assembly>
    <members>
        <member name="T:csscript.COM">
            <summary>
            COM HR checker: just to make code more compact;
            </summary>
        </member>
        <member name="T:csscript.IAssemblyCache">
            <summary>
            IAssemblyCache; COM import
            </summary>
        </member>
        <member name="T:csscript.IAssemblyName">
            <summary>
            IAssemblyName; COM import
            </summary>
        </member>
        <member name="T:csscript.IAssemblyEnum">
            <summary>
            IAssemblyEnum; COM import
            </summary>
        </member>
        <member name="T:csscript.AssemblyCommitFlags">
            <summary>
            AssemblyCommitFlags; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.AssemblyCacheFlags">
            <summary>
            AssemblyCacheFlags; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.AssemblyCacheUninstallDisposition">
            <summary>
            AssemblyCacheUninstallDisposition; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.CreateAssemblyNameObjectFlags">
            <summary>
            CreateAssemblyNameObjectFlags; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.AssemblyNameDisplayFlags">
            <summary>
            AssemblyNameDisplayFlags; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.InstallReference">
            <summary>
            InstallReference + struct initialization; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.AssemblyInfo">
            <summary>
            AssemblyInfo; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.InstallReferenceGuid">
            <summary>
            InstallReferenceGuid; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.AssemblyCache">
            <summary>
             Helper calss for IAssemblyCache
            </summary>
        </member>
        <member name="T:csscript.AssemblyEnum">
            <summary>
            Helper calss for IAssemblyEnum
            </summary>
        </member>
        <member name="T:CSScriptLibrary.ParsingParams">
            <summary>
            ParsingParams is an class that holds parsing parameters (parameters that controls how file is to be parsed).
            At this moment they are namespace renaming rules only.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ParsingParams.Compare(CSScriptLibrary.ParsingParams,CSScriptLibrary.ParsingParams)">
            <summary>
            Compare() is to be used to help with implementation of IComparer for sorting operations.
            </summary>
        </member>
        <member name="T:CSScriptLibrary.ScriptInfo">
            <summary>
            Class which is a placeholder for general information of the script file
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ScriptInfo.#ctor(csscript.CSharpParser.ImportInfo)">
            <summary>
            Constructor
            </summary>
            <param name="info">ImportInfo object containing the information how the script file should be parsed.</param>
        </member>
        <member name="T:CSScriptLibrary.FileParser">
            <summary>
            Class that implements parsing the single C# script file
            </summary>
        </member>
        <member name="M:CSScriptLibrary.FileParser.ResolveFile(System.String,System.String[])">
            <summary>
            Searches for script file by given script name. Calls ResolveFile(string fileName, string[] extraDirs, bool throwOnError)
            with throwOnError flag set to true.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.FileParser.ResolveFile(System.String,System.String[],System.Boolean)">
            <summary>
            Searches for script file by given script name. Search order:
            1. Current directory
            2. extraDirs (usually %CSSCRIPT_DIR%\Lib and ExtraLibDirectory)
            3. PATH
            Also fixes file name if user did not provide extension for script file (assuming .cs extension)
            </summary>
        </member>
        <member name="T:CSScriptLibrary.FileParserComparer">
             <summary>
             Class that implements parsing the single C# Script file
             </summary>
             <summary>
             Implementation of the IComparer for sorting operations of collections of FileParser instances
             </summary>
            
        </member>
        <member name="T:CSScriptLibrary.ScriptParser">
            <summary>
            Class that manages parsing the main and all imported (if any) C# Script files
            </summary>
        </member>
        <member name="F:CSScriptLibrary.ScriptParser.apartmentState">
            <summary>
            ApartmentState of a script during the execution (default: ApartmentState.Unknown)
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="fileName">Script file name</param>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.#ctor(System.String,System.String[])">
            <summary>
            Constructor.
            </summary>
            <param name="fileName">Script file name</param>
            <param name="searchDirs">Extra ScriptLibrary directory </param>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.#ctor(System.String,System.String[],System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="fileName">Script file name</param>
            <param name="searchDirs">Extra ScriptLibrary directory(ies) </param>
            <param name="throwOnError">flag to indicate if the file parsing/processing error should raise an exception</param>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.Init(System.String,System.String[])">
            <summary>
            Initialization of ScriptParser instance
            </summary>
            <param name="fileName">Script file name</param>
            <param name="searchDirs">Extra ScriptLibrary directory(ies) </param>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.SaveImportedScripts">
            <summary>
            Saves all imported scripts int temporary location.
            </summary>
            <returns>Collection of the saved imported scrips file names</returns>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.DeleteImportedFiles">
            <summary>
            Deletes imported scripts as a cleanup operation
            </summary>
        </member>
        <member name="F:CSScriptLibrary.ScriptParser.SearchDirs">
            <summary>
            CS-Script SearchDirectories specified in the parsed script or its dependent scripts.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.FilesToCompile">
            <summary>
            Collection of the files to be compiled (including dependant scripts)
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.ImportedFiles">
            <summary>
            Collection of the imported files (dependant scripts)
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.ReferencedResources">
            <summary>
            Collection of resource files referenced from code
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.CompilerOptions">
            <summary>
            Collection of compiler options
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.Precompilers">
            <summary>
            Precompilers specified in the primary script file.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.ReferencedNamespaces">
            <summary>
            Collection of namespaces referenced from code (including those referenced in dependand scripts)
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.IgnoreNamespaces">
            <summary>
            Collection of namespaces, which if found in code, should not be resolved into referenced assembly.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.ReferencedAssemblies">
            <summary>
            Collection of referenced asesemblies. All assemblies are referenced either from command-line, code or resolved from referenced namespaces.
            </summary>
        </member>
        <member name="T:csscript.PrecompilationContext">
            <summary>
            This class is a container for information related to the script precompilation.
            <para>It is used to pass an input information from the script engine to the <c>precompiler</c> instance as well as to pass back
            to the script engine some output information (e.g. added referenced assemblies)</para> .
            </summary>
        </member>
        <member name="F:csscript.PrecompilationContext.NewReferences">
            <summary>
            Collection of the referenced assemblies to be added to the process script referenced assemblies.
            <para>You may want to add new items to the referenced assemblies because of the precompilation logic (e.g. some code using assemblies not referenced by the primary script 
            is injected in the script).</para>
            </summary>
        </member>
        <member name="F:csscript.PrecompilationContext.NewDependencies">
            <summary>
            Collection of the new dependency items (files). 
            <para>Dependency files are checked before the script execution in order to understand if the script should be recompiled or it can be loaded from 
            the cache. If any of the dependency files is changed since the last script execution the script engine will recompile the script. In the simple execution 
            scenarios the script file is a dependency file.</para>
            </summary>
        </member>
        <member name="F:csscript.PrecompilationContext.NewIncludes">
            <summary>
            Collection of the new 'include' items (dependency source files). 
            </summary>
        </member>
        <member name="F:csscript.PrecompilationContext.NewSearchDirs">
            <summary>
            Collection of the assembly and script probing directories to be added to the process search directories.
            <para>You may want to add new items to the process search directories because of the precompilation logic.</para>
            </summary>
        </member>
        <member name="F:csscript.PrecompilationContext.SearchDirs">
            <summary>
            Collection of the process assembly and script probing directories.
            </summary>
        </member>
        <member name="T:csscript.AutoclassGenerator">
            <summary>
            AutoclassGenerator to be used by external applications for generating the auto-class from the classless scripts
            </summary>
        </member>
        <member name="M:csscript.AutoclassGenerator.Process(System.String,System.Int32@,System.Int32@)">
            <summary>
            Processes the specified code.
            </summary>
            <param name="code">The code.</param>
            <param name="injectionPos">The injection position.</param>
            <param name="injectionLength">Length of the injection.</param>
            <returns></returns>
        </member>
        <member name="M:csscript.AutoclassGenerator.Process(System.String,System.Int32@)">
            <summary>
            Processes the specified code.
            </summary>
            <param name="code">The code.</param>
            <param name="position">The position.</param>
            <returns></returns>
        </member>
        <member name="T:csscript.CSExecutor">
            <summary>
            CSExecutor is an class that implements execution of *.cs files.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.Execute(System.String[],csscript.PrintDelegate,System.String)">
            <summary>
            The main entry point for the application.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.GetCustomAppConfig(System.String[])">
            <summary>
            Returns custom application config file.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.VoidPrint(System.String)">
            <summary>
            Dummy 'print' to suppress displaying application messages.
            </summary>
        </member>
        <member name="F:csscript.CSExecutor.lastException">
            <summary>
            This method implements compiling and execution of the script.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.ExecuteImpl">
            <summary>
            This method implements compiling and execution of the script.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.Compile(System.String,System.String,System.Boolean)">
            <summary>
            Compiles C# script file into assembly.
            </summary>
        </member>
        <member name="F:csscript.CSExecutor.scriptArgs">
            <summary>
            C# Script arguments array (sub array of application arguments array).
            </summary>
        </member>
        <member name="F:csscript.CSExecutor.print">
            <summary>
            Callback to print application messages to appropriate output.
            </summary>
        </member>
        <member name="F:csscript.CSExecutor.options">
            <summary>
            Container for parsed command line arguments
            </summary>
        </member>
        <member name="F:csscript.CSExecutor.rethrow">
            <summary>
            Flag to force to rethrow critical exceptions
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.#ctor(System.Boolean,csscript.ExecuteOptions)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.GetAvailableAssembly(System.String)">
            <summary>
            Checks/returns if compiled C# script file (ScriptName + ".compiled") available and valid.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.Compile(System.String)">
            <summary>
            Compiles C# script file.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.GetScriptTempFile">
            <summary>
            Returns the name of the temporary file in the CSSCRIPT subfolder of Path.GetTempPath().
            </summary>
            <returns>Temporary file name.</returns>
        </member>
        <member name="M:csscript.CSExecutor.GetScriptTempDir">
            <summary>
            Returns the name of the temporary folder in the CSSCRIPT subfolder of Path.GetTempPath().
            <para>Under certain circumstances it may be desirable to the use the alternative location for the CS-Script temporary files.
            In such cases use SetScriptTempDir() to set the alternative location.
            </para>
            </summary>
            <returns>Temporary directory name.</returns>
        </member>
        <member name="M:csscript.CSExecutor.SetScriptTempDir(System.String)">
            <summary>
            Sets the location for the CS-Script temporary files directory.
            </summary>
            <param name="path">The path for the temporary directory.</param>
        </member>
        <member name="M:csscript.CSExecutor.GetCacheDirectory(System.String)">
            <summary>
            Generates the name of the cache directory for the specified script file.
            </summary>
            <param name="file">Script file name.</param>
            <returns>Cache directory name.</returns>
        </member>
        <member name="M:csscript.CSExecutor.SetScriptCacheDir(System.String)">
            <summary>
            Generates the name of the temporary cache folder in the CSSCRIPT subfolder of Path.GetTempPath(). The cache folder is specific for every script file.
            </summary>
            <param name="scriptFile">script file</param>
        </member>
        <member name="M:csscript.CSExecutor.ShowHelp">
            <summary>
            Prints Help info.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.ShowSample">
            <summary>
            Show sample C# script file.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.ShowPrecompilerSample">
            <summary>
            Show sample precompiler C# script file.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.CreateDefaultConfigFile">
            <summary>
            Creates the default config file in the CurrentDirectory.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.ShowVersion">
            <summary>
            Show CS-Script version information.
            </summary>
        </member>
        <member name="P:csscript.CSExecutor.Rethrow">
            <summary>
            Force caught exceptions to be rethrown.
            </summary>
        </member>
        <member name="P:csscript.CSExecutor.ScriptCacheDir">
            <summary>
             Contains the name of the temporary cache folder in the CSSCRIPT subfolder of Path.GetTempPath(). The cache folder is specific for every script file.
             </summary>
        </member>
        <member name="T:csscript.CSharpParser">
            <summary>
            Very light parser for C# code. The main purpose of it is to be very fast and reliable.
            It only extracts code information relative to the CS-Script.
            </summary>
        </member>
        <member name="M:csscript.CSharpParser.#ctor(System.String)">
            <summary>
            Creates an instance of CSharpParser.
            </summary>
            <param name="code">C# code string</param>
        </member>
        <member name="M:csscript.CSharpParser.#ctor(System.String,System.Boolean)">
            <summary>
            Creates an instance of CSharpParser.
            </summary>
            <param name="script">C# script (code or file).</param>
            <param name="isFile">If set to 'true' the script is a file, otherwise it is a C# code.</param>
        </member>
        <member name="M:csscript.CSharpParser.#ctor(System.String,System.Boolean,System.String[])">
            <summary>
            Creates an instance of CSharpParser.
            </summary>
            <param name="script">C# script (code or file).</param>
            <param name="isFile">If set to 'true' the script is a file, otherwise it is a C# code.</param>
            <param name="directivesToSearch">Additional C# script directives to search. The search result is stored in CSharpParser.CustomDirectives.</param>
        </member>
        <member name="F:csscript.CSharpParser.CustomDirectives">
            <summary>
            The result of search for additional C# script directives to search (directive vs. value).
            </summary>
        </member>
        <member name="M:csscript.CSharpParser.Init(System.String,System.String)">
            <summary>
            Parses the C# code. Only one of the 'code' and 'file' parameters can be non empty.
            </summary>
            <param name="code">C# script code (empty string if code is in a file form).</param>
            <param name="file">The script file name (empty if code is in the text form).</param>
        </member>
        <member name="M:csscript.CSharpParser.Init(System.String,System.String,System.String[])">
            <summary>
            Parses the C# code.
            </summary>
            <param name="code">C# script (code or file).</param>
            <param name="file">If set to 'true' the script is a file, otherwise it is a C# code.</param>
            <param name="directivesToSearch">Additional C# script directives to search. The search result is stored in CSharpParser.CustomDirectives.</param>
        </member>
        <member name="M:csscript.CSharpParser.DoRenaming(System.String[][],System.Boolean)">
            <summary>
            Renames namespaces according renaming instructions.
            </summary>
            <param name="renamingMap">Renaming instructions (old_name vs. new_name).</param>
            <param name="preserveMain">/// If set to 'true' "static...Main" in the imported script is not renamed.</param>
        </member>
        <member name="F:csscript.CSharpParser.OpenEndDirectiveSyntax">
            <summary>
            Enables omitting closing character (";") for CS-Script directives (e.g. "//css_ref System.Xml.dll" instead of "//css_ref System.Xml.dll;").
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.Args">
            <summary>
            Embedded script arguments. The both script and engine arguments are allowed except "/noconfig" engine command line switch.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.CompilerOptions">
            <summary>
            Embedded compiler options.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.HostOptions">
            <summary>
            Embedded compiler options.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.Precompilers">
            <summary>
            Precompilers.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.References">
            <summary>
            References to the external assemblies and namespaces.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.RefAssemblies">
            <summary>
            References to the external assemblies.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.IgnoreNamespaces">
            <summary>
            Names of namespaces to be ignored by namespace-to-assembly resolver.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.ExtraSearchDirs">
            <summary>
            Additional search directories (for script and assembly probing).
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.ResFiles">
            <summary>
            References to the resource files.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.RefNamespaces">
            <summary>
            References to the namespaces.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.Imports">
            <summary>
            C# scripts to be imported.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.CmdScripts">
            <summary>
            Pre- and post-execution scripts.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.ThreadingModel">
            <summary>
            Appartment state of the script.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.Code">
            <summary>
            Script C# raw code.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.ModifiedCode">
            <summary>
            Script C# code after namespace renaming.
            </summary>
        </member>
        <member name="T:csscript.CSharpParser.CmdScriptInfo">
            <summary>
            Class to hold the script information on what pre- or post-execution script needs to be executed.
            pre- and post-script CS-Script command format:
            //css_prescript file([arg0][, arg1]..[,arg2])[,ignore];
            //file - script file (extension is optional)
            //arg0..N - script string arguments;
            If $this is specified as arg0..N it will be replaced with the parent script full name at execution time.
            </summary>
        </member>
        <member name="M:csscript.CSharpParser.CmdScriptInfo.#ctor(System.String,System.Boolean,System.String)">
            <summary>
            Creates an instance of CmdScriptInfo.
            </summary>
            <param name="statement">CS-Script pre- or post-script directive</param>
            <param name="preScript">If set to true the 'statement' is a pre-script otherwise it is a post-script.</param>
            <param name="parentScript">The file name of the main script.</param>
        </member>
        <member name="F:csscript.CSharpParser.CmdScriptInfo.args">
            <summary>
            Script file and it's arguments.
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.CmdScriptInfo.preScript">
            <summary>
            If set to 'true' the CmdScriptInfo describes the pre-script, otherwise it is for the post-script.
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.CmdScriptInfo.abortOnError">
            <summary>
            If set to 'true' parent script will be aborted on pre/post-script error, otherwise the error will be ignored.
            </summary>
        </member>
        <member name="T:csscript.CSharpParser.ImportInfo">
            <summary>
            Class to hold the script importing information, which actually controls how script is imported.
            </summary>
        </member>
        <member name="M:csscript.CSharpParser.ImportInfo.#ctor(System.String,System.String)">
            <summary>
            Creates an instance of ImportInfo.
            </summary>
            <param name="statement">CS-Script import directive (//css_import...) string.</param>
            <param name="parentScript">name of the parent (primary) script file.</param>
        </member>
        <member name="F:csscript.CSharpParser.ImportInfo.file">
            <summary>
            The file to be imporeted.
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.ImportInfo.renaming">
            <summary>
            Renaming instructions (old_name vs. new_name)
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.ImportInfo.preserveMain">
            <summary>
            If set to 'true' "static...Main" in the imported script is not renamed.
            </summary>
        </member>
        <member name="T:CSScriptLibrary.AssemblyResolver">
            <summary>
            Class for resolving assembly name to assembly file
            </summary>
        </member>
        <member name="F:CSScriptLibrary.AssemblyResolver.ignoreFileName">
            <summary>
            File to be excluded from assembly search
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.ResolveAssembly(System.String,System.String,System.Boolean)">
            <summary>
            Resolves assembly name to assembly file. Loads assembly file to the current AppDomain.
            </summary>
            <param name="assemblyName">The name of assembly</param>
            <param name="dir">The name of directory where local assemblies are expected to be</param>
            <param name="throwExceptions">if set to <c>true</c> [throw exceptions].</param>
            <returns>loaded assembly</returns>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.IsLegalPathToken(System.String)">
            <summary>
            Determines whether the string is a legal path token.
            </summary>
            <param name="name">The name.</param>
            <returns>
            	<c>true</c> if the string is a legal path token; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.FindAssembly(System.String,System.String[])">
            <summary>
            Resolves namespace/assembly(file) name into array of assembly locations (local and GAC ones).
            </summary>
            <param name="name">'namespace'/assembly(file) name</param>
            <param name="searchDirs">Assembly search directories</param>
            <returns>collection of assembly file names where namespace is implemented</returns>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.FindLocalAssembly(System.String,System.String)">
            <summary>
            Resolves namespace into array of local assembly locations.
            (Currently it returns only one assembly location but in future
            it can be extended to collect all assemblies with the same namespace)
            </summary>
            <param name="name">namespace/assembly name</param>
            <param name="dir">directory</param>
            <returns>collection of assembly file names where namespace is implemented</returns>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.FindGlobalAssembly(System.String)">
            <summary>
            Resolves namespace into array of global assembly (GAC) locations.
            </summary>
            <param name="namespaceStr">'namespace' name</param>
            <returns>collection of assembly file names where namespace is implemented</returns>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.IsNamespaceDefinedInAssembly(System.String,System.String)">
            <summary>
            Search for namespace into local assembly file.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.AssemblyResolver.CacheProbingResults">
            <summary>
            Gets or sets a value indicating whether the assembly probing results should be cached. Default value is <c>false</c>;
            <para>
            Caching means that during the probing if the assembly is not found in one of the probing directories this directory will not
            be checked again if the same assembly is to be resolved in the future.
            </para>
            <para>
            This setting is to be used with the caution. While it can bring some performance benefits when the list of probing directories
            is large it also may be wrong to assume that if the assembly in not found in a particular directory it still will not be there if the probing is repeated.
            </para>
            </summary>
            <value><c>true</c> if probing results should be cached; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:csscript.AssemblyExecutor">
            <summary>
            Executes "public static void Main(..)" of assembly in a separate domain.
            </summary>
        </member>
        <member name="T:csscript.RemoteExecutor">
            <summary>
            Invokes static method 'Main' from the assembly.
            </summary>
        </member>
        <member name="M:csscript.RemoteExecutor.ResolveEventHandler(System.Object,System.ResolveEventArgs)">
            <summary>
            AppDomain event handler. This handler will be called if CLR cannot resolve
            referenced local assemblies
            </summary>
        </member>
        <member name="T:csscript.CompilerException">
            <summary>
            The exception that is thrown when a the script compiler error occurs.
            </summary>
        </member>
        <member name="M:csscript.CompilerException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:csscript.CompilerException"/> class.
            </summary>
        </member>
        <member name="M:csscript.CompilerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:csscript.CompilerException"/> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="M:csscript.CompilerException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:csscript.CompilerException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:csscript.CompilerException.Create(System.CodeDom.Compiler.CompilerErrorCollection,System.Boolean)">
            <summary>
            Creates the CompilerException instance from the specified compiler errors errors.
            </summary>
            <param name="Errors">The compiler errors.</param>
            <param name="hideCompilerWarnings">if set to <c>true</c> hide compiler warnings.</param>
            <returns></returns>
        </member>
        <member name="T:csscript.ExecuteOptions">
            <summary>
            Application specific runtime settings
            </summary>
        </member>
        <member name="T:csscript.Settings">
            <summary>
            Settings is an class that holds CS-Script application settings.
            </summary>
        </member>
        <member name="M:csscript.Settings.ExpandCleanupShellCommand">
            <summary>
            Returns value of the CleanupShellCommand (with expanding environment variables).
            </summary>
            <returns>shell command string</returns>
        </member>
        <member name="M:csscript.Settings.ExpandUseAlternativeCompiler">
            <summary>
            Returns value of the UseAlternativeCompiler (with expanding environment variables).
            </summary>
            <returns>Path string</returns>
        </member>
        <member name="M:csscript.Settings.ExpandUsePostProcessor">
            <summary>
            Returns value of the UsePostProcessor (with expanding environment variables).
            </summary>
            <returns>Path string</returns>
        </member>
        <member name="M:csscript.Settings.ExpandDefaultRefAssemblies">
            <summary>
            Returns value of the DefaultRefAssemblies (with expanding environment variables).
            </summary>
            <returns>List of assembly names</returns>
        </member>
        <member name="M:csscript.Settings.AddSearchDir(System.String)">
            <summary>
            Add search directory to the search (probing) path Settings.SearchDirs.
            For example if Settings.SearchDirs = "c:\scripts" then after call Settings.AddSearchDir("c:\temp") Settings.SearchDirs is "c:\scripts;c:\temp"
            </summary>
            <param name="dir">Directory path.</param>
        </member>
        <member name="M:csscript.Settings.Save(System.String)">
            <summary>
            Saves CS-Script application settings to a file (.dat).
            </summary>
            <param name="fileName">File name of the .dat file</param>
        </member>
        <member name="M:csscript.Settings.Load(System.String)">
            <summary>
            Loads CS-Script application settings from a file. Default settings object is returned if it cannot be loaded from the file.
            </summary>
            <param name="fileName">File name of the XML file</param>
            <returns>Setting object desterilized from the XML file</returns>
        </member>
        <member name="M:csscript.Settings.Load(System.String,System.Boolean)">
            <summary>
            Loads CS-Script application settings from a file.
            </summary>
            <param name="fileName">File name of the XML file</param>
            <param name="createAlways">Create and return default settings object if it cannot be loaded from the file.</param>
            <returns>Setting object desterilized from the XML file</returns>
        </member>
        <member name="P:csscript.Settings.CleanupShellCommand">
             <summary>
             Command to be executed to perform custom cleanup.
             If this value is empty automatic cleanup of all
             temporary files will occurs after the script execution.
             This implies that the script has to be executed in the
             separate AppDomain and some performance penalty will be incurred.
            
             Setting this value to the command for custom cleanup application
             (e.g. csc.exe cleanTemp.cs) will force the script engine to execute
             script in the 'current' AppDomain what will improve performance.
             </summary>
        </member>
        <member name="P:csscript.Settings.DoCleanupAfterNumberOfRuns">
            <summary>
            This value indicates frequency of the custom cleanup
            operation. It has affect only if CleanupShellCommand is not empty.
            </summary>
        </member>
        <member name="P:csscript.Settings.UseAlternativeCompiler">
            <summary>
            Location of alternative code provider assembly. If set it forces script engine to use an alternative code compiler.
            </summary>
        </member>
        <member name="P:csscript.Settings.UsePostProcessor">
            <summary>
            Location of PostProcessor assembly. If set it forces script engine to pass compiled script through PostProcessor before the execution.
            </summary>
        </member>
        <member name="P:csscript.Settings.DefaultApartmentState">
            <summary>
            DefaultApartmentState is an ApartmemntState, which will be used
            at run-time if none specified in the code with COM threading model attributes.
            </summary>
        </member>
        <member name="P:csscript.Settings.DefaultArguments">
            <summary>
            Default command-line arguments. For example if "/dbg" is specified all scripts will be compiled in debug mode
            regardless if the user specified "/dbg" when a particular script is launched.
            </summary>
        </member>
        <member name="P:csscript.Settings.OpenEndDirectiveSyntax">
            <summary>
            Enables omitting closing character (";") for CS-Script directives (e.g. "//css_ref System.Xml.dll" instead of "//css_ref System.Xml.dll;").
            </summary>
        </member>
        <member name="P:csscript.Settings.TargetFramework">
            <summary>
            Specifies the .NET Framework version that the script is compiled against. This option can have the following values:
              v2.0
              v3.0
              v3.5
              v4.0
            </summary>
        </member>
        <member name="P:csscript.Settings.CompilerFramework">
            <summary>
            Specifies the .NET Framework version that the script is compiled against. This option can have the following values:
              v2.0
              v3.0
              v3.5
              v4.0
            </summary>
        </member>
        <member name="P:csscript.Settings.DefaultRefAssemblies">
            <summary>
            List of assembly names to be automatically referenced by the script. The items must be separated by coma or semicolon. Specifying .dll extension (e.g. System.Core.dll) is optional.
            Assembly can contain expandable environment variables.
            </summary>
        </member>
        <member name="P:csscript.Settings.SearchDirs">
            <summary>
            List of directories to be used to search (probing) for referenced assemblies and script files.
            This setting is similar to the system environment variable PATH.
            </summary>
        </member>
        <member name="P:csscript.Settings.HideAutoGeneratedFiles">
            <summary>
            The value, which indicates if auto-generated files (if any) should should be hidden in the temporary directory.
            </summary>
        </member>
        <member name="P:csscript.Settings.Precompiler">
            <summary>
            Path to the precompiller script/assembly (see documentation for details). You can specify multiple recompiles separating them by semicolon.
            </summary>
        </member>
        <member name="P:csscript.Settings.CustomHashing">
            <summary>
            Gets or sets a value indicating whether custom string hashing algorithm should be used.
            <para>
            String hashing is used by the script engine for allocating temporary and cached paths. 
            However default string hashing is platform dependant (x32 vs. x64) what makes impossible 
            truly deterministic string hashing. This in turns complicates the integration of the 
            CS-Script infrastructure with the third-party applications (e.g. Notepad++ CS-Script plugin).
            </para>
            <para>
            To overcome this problem CS-Script uses custom string hashing algorithm (default setting).
            Though the native .NET hashing can be enabled if desired by setting <c>CustomHashing</c>
            to <c>false</c>.</para>
            </summary>
            <value>
              <c>true</c> if custom hashing is in use; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:csscript.Settings.ReportDetailedErrorInfo">
            <summary>
            Boolean flag that indicates how much error details to be reported should error occur.
            false - Top level exception will be reported
            true - Whole exception stack will be reported
            </summary>
        </member>
        <member name="P:csscript.Settings.OptimisticConcurrencyModel">
            <summary>
            Gets or sets a value indicating whether Optimistic Concurrency model should be used when executing scripts from the host application.
            If set to <c>false</c> the script loading (not the execution) is globally thread-safe. If set to <c>true</c> the script loading is
            thread-safe only among loading operations for the same script file.
            <para>The default value is <c>true</c>.</para>
            </summary>
            <value>
            	<c>true</c> if Optimistic Concurrency model otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:csscript.Settings.HideCompilerWarnings">
            <summary>
            Boolean flag that indicates if compiler warnings should be included in script compilation output.
            false - warnings will be displayed
            true - warnings will not be displayed
            </summary>
        </member>
        <member name="P:csscript.Settings.InMemoryAsssembly">
            <summary>
            Boolean flag that indicates the script assembly is to be loaded by CLR as an in-memory byte stream instead of the file.
            This setting can be useful when you need to prevent script assembly (compiled script) from locking by CLR during the execution.
            false - script assembly will be loaded as a file. It is an equivalent of Assembly.LoadFrom(string assemblyFile).
            true - script assembly will be loaded as a file. It is an equivalent of Assembly.Load(byte[] rawAssembly)
            </summary>
        </member>
        <member name="T:csscript.Settings.HideOptions">
            <summary>
            Enum for possible hide auto-generated files scenarios
            Note: when HideAll is used it is responsibility of the pre/post script to implement actual hiding.
            </summary>
        </member>
        <member name="F:csscript.Settings.HideOptions.DoNotHide">
            <summary>
            Do not hide auto-generated files.
            </summary>
        </member>
        <member name="F:csscript.Settings.HideOptions.HideMostFiles">
            <summary>
            Hide the most of the auto-generated (cache and "imported") files.
            </summary>
        </member>
        <member name="F:csscript.Settings.HideOptions.HideAll">
            <summary>
            Hide all auto-generated files including the files generated by pre/post scripts.
            </summary>
        </member>
        <member name="M:csscript.Utils.AddCompilerOptions(System.CodeDom.Compiler.CompilerParameters,System.String)">
            <summary>
            Adds compiler options to the CompilerParameters in a manner that it does separate every option by the space character
            </summary>
        </member>
        <member name="M:csscript.CSSUtils.ParseAppArgs(System.String[],csscript.IScriptExecutor)">
            <summary>
            Parses application (script engine) arguments.
            </summary>
            <param name="args">Arguments</param>
            <param name="executor">Script executor instance</param>
            <returns>Index of the first script argument.</returns>
        </member>
        <member name="T:csscript.MetaDataItems">
             <summary>
             The MetaDataItems class contains information about script dependencies (referenced local
             assemblies and imported scripts) and compiler options. This information is required when
             scripts are executed in a 'cached' mode (/c switch). On the base of this information the script
             engine will compile new version of .compiled assembly if any of it's dependencies is changed. This
             is required even for referenced local assemblies as it is possible that they are a strongly
             named assemblies (recompiling is required for any compiled client of the strongly named assembly
             in case this assembly is changed).
            
             The perfect place to store the dependencies info (custom meta data) is the assembly
             resources. However if we do so such assemblies would have to be loaded in order to read their
             resources. It is not acceptable as after loading assembly cannot be unloaded. Also assembly loading
             can significantly compromise performance.
            
             That is why custom meta data is just physically appended to the file. This is a valid
             approach because such assembly is not to be distributed anywhere but to stay always
             on the PC and play the role of the temporary data for the script engine.
            
             Note: A .dll assembly is always compiled and linked in a normal way without any custom meta data attached.
             </summary>
        </member>
        <member name="T:CSScriptLibrary.Ref`1">
             <summary>
             This class encapsulates another object for the purpose of passing it to the anonymous methods as parameters.
             <para>This lass helps to overcome the problem when <c>struct</c> or <c>immutable</c> types cannot be passed to the
             anonymous methods with the <c>ref</c> modifier.</para>
             <example>The following is the example of the updating the local variable of a value type from the anonymous method:
            <code>
             var count = new Ref&lt;int&gt;(1);
            
             Action&lt;Ref&lt;int&gt;&gt; increment =
                               arg =>
                               {
                                   arg.Value += 1;
                               };
            
             increment(count);
             </code>
             </example>
             </summary>
             <typeparam name="T">Type of the encapsulated object.</typeparam>
        </member>
        <member name="M:CSScriptLibrary.Ref`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:CSScriptLibrary.Ref`1"/> class.
            </summary>
            <param name="value">The object to be encapsulated.</param>
        </member>
        <member name="M:CSScriptLibrary.Ref`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents encapsulated object.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents encapsulated object.
            </returns>
        </member>
        <member name="P:CSScriptLibrary.Ref`1.Value">
            <summary>
            Gets or sets the value of the encapsulated object.
            </summary>
            <value>
            The value.
            </value>
        </member>
        <member name="T:CSScriptLibrary.AppDomainHelper">
            <summary>
            Simple helper class for extending functionality of <see cref="T:System.AppDomain" />.
            <para>
            This class mainly consist of the extension methods for <see cref="T:System.AppDomain" /> and it is to be used for executing the arbitrary
            code routines in the separate (temporary) <see cref="T:System.AppDomain" /> with the optional unloading.
            </para>This class is particularly useful for executing the CS-Script script in the separate <see cref="T:System.AppDomain" /> as this is the
            only way to unload the script assembly after the execution (known .NET limitation).
            <para>
            <example>The following are the examples of the execution CS-Script scripts and unloading them after the execution:
            <code>
            AppDomain.CurrentDomain
            .Clone()
            .Execute(Job)
            .Unload();
            ...
            void Job()
            {
            var script = CSScript.LoadMethod("some C# script code")
            .GetStaticMethod();
            script();
            };
            </code>
            <code>
            AppDomain remote = AppDomain.CurrentDomain.Clone();
            remote.Execute(() =&gt;
            {
            var Sum = CSScript.BuildEval(@"func(float a, float b) {
            return a + b;
            }");
            var Average = CSScript.BuildEval(@"func(float a, float b) {
            return (a + b)/2;
            }");
            Console.WriteLine("Sum = {0}\nAverage={1}", Sum(1f, 2f), Average(1f, 2f));
            });
            remote.Unload();
            </code>
            </example>
            </para>
            <remarks>
            The functionality of this class is very similar to the <see cref="T:CSScriptLibrary.AsmHelper" />, which also allows executing and unloading the script(s).
            However  <see cref="T:CSScriptLibrary.AppDomainHelper" /> is designed as a generic class and as such it is more suitable for executing a "job" routines instead of individual scripts.
            <para>
            This creates some attractive opportunities for grouping scripting routines in a single <see cref="T:CSScriptLibrary.AsmHelper" />, which allows simple calling conventions (e.g. <c>CSScript.Load()</c>
            instead of <c>CSScript.Compile()</c>) lighter type system (e.g. no need for MarshalByRefObject inheritance).
            </para>
            </remarks>
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AppDomainHelper.Execute(System.AppDomain,System.Action)">
             <summary>
             Executes the <see cref="T:System.Action"/> delegate in the specified <see cref="T:System.AppDomain"/>.
             <example>The following are the examples of the execution CS-Script scripts and unloading them after the execution:
            <code>
             var remoteDomain = AppDomain.CurrentDomain.Clone();
             remoteDomain.Execute(Job)
             remoteDomain.Unload();
             ...
            
             void Job()
             {
                 var script = CSScript.LoadMethod("some C# script code")
                                      .GetStaticMethod();
                 script();
             };
             </code>
             </example>
             </summary>
             <param name="domain">The <see cref="T:System.AppDomain"/> the delegate should be executed in.</param>
             <param name="action">The delegate.</param>
             <returns>Reference to the <see cref="T:System.AppDomain"/>. It is the same object, which is passed as the <paramref name="domain"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.AppDomainHelper.Execute``1(System.AppDomain,System.Action{``0},``0)">
             <summary>
             Executes the <see cref="T:System.Action"/> delegate in the specified <see cref="T:System.AppDomain"/>.
             <para>This method is allows you to pass the execution context parameter of the <c>T</c> type. Note <c>T</c> type must be serializable or inherited from
             <c>MarshalByRefObject</c>.</para>
             <para>This technique allows using AppDomain-neutral anonymous methods, which do not directly reference any variables from the primary
             <c>AddDomain</c> and yet allow interacting with this domain through the context parameter.</para>
             <example>The following is the example of the updating the primary AppDomain local variable <c>foo</c> from the routine executed in the remote domain:
            <code>
             var foo = new Ref&lt;string&gt;("foo");
             AppDomain.CurrentDomain
                      .Clone()
                      .Execute(arg =&gt;
                               {
                                   arg.Value = "FOO";
                               }, foo)
                      .Unload();
             </code>
             Note that the example is using <see cref="T:CSScriptLibrary.Ref&lt;T&gt;"/> type to to allow custom boxing. This is because the anonymous methods do not allow ref/out parameter modifiers.
             </example>
             </summary>
             <typeparam name="T"></typeparam>
             <param name="domain">The <see cref="T:System.AppDomain"/> the delegate should be executed in.</param>
             <param name="action">The delegate.</param>
             <param name="context">The context data. Note the type of this parameter must be either <c>serializable</c> or inherited from <c>MarshalByRefObject </c> .</param>
             <returns>Reference to the <see cref="T:System.AppDomain"/>. It is the same object, which is passed as the <paramref name="domain"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.AppDomainHelper.ExecuteAndUnload(System.Action)">
             <summary>
             <para>Executes the delegate in the temporary <see cref="T:System.AppDomain"/> with the following unloading of this domain.
             </para>
             <example>The following code the complete equivalent implementation of the <c>ExecuteAndUnload</c>:
            <code>
             AppDomain.CurrentDomain
                      .Clone()
                      .Execute(action)
                      .Unload();
             </code>
             </example>
             </summary>
             <param name="action">The delegate to be executed.</param>
        </member>
        <member name="M:CSScriptLibrary.AppDomainHelper.Unload(System.AppDomain)">
            <summary>
            Unloads the specified <see cref="T:System.AppDomain"/>.
            </summary>
            <param name="domain">The <see cref="T:System.AppDomain"/> to be unloaded.</param>
        </member>
        <member name="M:CSScriptLibrary.AppDomainHelper.Clone(System.AppDomain)">
            <summary>
            Clones the specified <see cref="T:System.AppDomain"/>. The mandatory "creation" properties of the <paramref name="domain"/> are used to create the new instance of <see cref="T:System.AppDomain"/>.
            <para>The "friendly name" of the cloned <see cref="T:System.AppDomain"/> is a string representation of the random <c>GUID</c>.</para>
            </summary>
            <param name="domain">The <see cref="T:System.AppDomain"/> to be cloned.</param>
            <returns>The newly created <see cref="T:System.AppDomain"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.AppDomainHelper.Clone(System.AppDomain,System.String,System.Security.PermissionSet,System.Security.Policy.StrongName[])">
            <summary>
            Clones the specified <see cref="T:System.AppDomain"/>. The mandatory "creation" properties of the <paramref name="domain"/> are used to create the new instance of <see cref="T:System.AppDomain"/>.
            <para>The <paramref name="name"/> parameter is used as the "friendly name" for the cloned <see cref="T:System.AppDomain"/>.</para>
            </summary>
            <param name="domain">The <see cref="T:System.AppDomain"/> to be cloned.</param>
            <param name="name">The "friendly name" of the new <see cref="T:System.AppDomain"/> to be created.</param>
            <param name="permissions">The permissions.</param>
            <param name="fullyTrustedAssemblies">The fully trusted assemblies.</param>
            <returns>The newly created <see cref="T:System.AppDomain"/>.</returns>
        </member>
        <member name="T:CSScriptLibrary.Sandbox">
            <summary>
            Simple security helper class. This class is nothing else but a syntactic sugar.
            <para>
            <example>The following is an example of execution under .NET sandbox:
            <code>
            Sandbox.With(SecurityPermissionFlag.Execution)
                   .Execute(() =>
                            {
                                //call sandboxed actions
                            });
            </code>
            </example>
            </para>
            </summary>
        </member>
        <member name="M:CSScriptLibrary.Sandbox.Execute(System.Security.PermissionSet,CSScriptLibrary.Sandbox.Action)">
            <summary>
            Extension method. Executes <see cref="T:System.Action"/> with the specified array of permissions
            </summary>
            <param name="permissions">The permissions set to be used for the execution.</param>
            <param name="action">The action to be executed.</param>
        </member>
        <member name="M:CSScriptLibrary.Sandbox.With(System.Security.IPermission[])">
            <summary>
            Returns the specified permissions as <see cref="T:System.Security.PermissionSet"/> to be used with <see cref="T:CSScriptLibrary.Sandbox.Execute"/>.
            </summary>
            <param name="permissions">The permissions.</param>
            <returns><see cref="T:System.Security.PermissionSet"/> instance.</returns>
        </member>
        <member name="M:CSScriptLibrary.Sandbox.With(System.Security.Permissions.SecurityPermissionFlag)">
            <summary>
            Returns the specified permissions as <see cref="T:System.Security.PermissionSet"/> to be used with <see cref="T:csscript.Sandbox.Execute"/>.
            </summary>
            <param name="permissionsFlag">The permissions flag. Can be combination of multiple values.</param>
            <returns><see cref="T:System.Security.PermissionSet"/> instance.</returns>
        </member>
        <member name="T:CSScriptLibrary.Sandbox.Action">
            <summary>
            Generic void/void delegate
            </summary>
        </member>
        <member name="T:CSScriptLibrary.PrintDelegate">
            <summary>
            Delegate to handle output from script
            </summary>
        </member>
        <member name="T:CSScriptLibrary.IsOutOfDateResolver">
            <summary>
            Delegate to determine if the script assembly is out of data and needs to be recompiled
            </summary>
            <param name="scriptSource">The script source.</param>
            <param name="scriptAssembly">The script assembly.</param>
            <returns>'true' if the script assembly is out of date.</returns>
        </member>
        <member name="T:CSScriptLibrary.CSScript">
            <summary>
            Class which is implements CS-Script class library interface.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetScriptName(System.Reflection.Assembly)">
            <summary>
            Determines whether the specified assembly is a script assembly (compiled script) and returns full path of the script file
            used to compile the assembly. The analysis is based on the fact that script assembly (in hosing scenarios) is always
            stamped with <see cref="T:System.Reflection.AssemblyDescriptionAttribute"/>, which contains name of the script file the
            assembly was compiled from.
            <para>The format of the description </para>
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>
            	Script file path if the specified assembly is a script assembly otherwise <c>null</c>.
            </returns>
        </member>
        <member name="F:CSScriptLibrary.CSScript.GlobalSettings">
            <summary>
            Settings object containing runtime settings, which controls script compilation/execution.
            This is Settings class essentially is a deserialized content of the CS-Script configuration file (css_config.xml).
            </summary>
        </member>
        <member name="F:CSScriptLibrary.CSScript.CompilingHistory">
            <summary>
            Collection of all compiling results. Every time the script is compiled the compiling result is added to this collection regardless of
            the success or failure of the actual compilation.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Execute(CSScriptLibrary.PrintDelegate,System.String[])">
            <summary>
            Invokes global (static) CSExecutor (C# script engine)
            </summary>
            <param name="print">Print delegate to be used (if not null) to handle script engine output (eg. compilation errors).</param>
            <param name="args">Script arguments.</param>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Execute(CSScriptLibrary.PrintDelegate,System.String[],System.Boolean)">
            <summary>
            Invokes CSExecutor (C# script engine)
            </summary>
            <param name="print">Print delegate to be used (if not null) to handle script engine output (eg. compilation errors).</param>
            <param name="args">Script arguments.</param>
            <param name="rethrow">Flag, which indicated if script exceptions should be rethrowed by the script engine without any handling.</param>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileCode(System.String,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileCode(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetScriptTempFile">
            <summary>
            Returns the name of the temporary file in the CSSCRIPT subfolder of Path.GetTempPath().
            </summary>
            <returns>Temporary file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetScriptTempDir">
            <summary>
            Returns the name of the CSScript temporary folder.
            </summary>
            <returns>Temporary folder name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Compile(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Compile(System.String,System.String[])">
            <summary>
            Compiles script file into assembly (temporary file) with CSExecutor.
            This method is an equivalent of the CSScript.Compile(scriptFile, null, false);
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileWithConfig(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Compiles script file into assembly with CSExecutor. Uses specified config file to load script engine settings.
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="cssConfigFile">The name of CS-Script configuration file. If null the default config file will be used (appDir/css_config.xml).</param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileWithConfig(System.String,System.String,System.Boolean,System.String,System.String,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor. Uses specified config file to load script engine settings and compiler specific options.
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="cssConfigFile">The name of CS-Script configuration file. If null the default config file will be used (appDir/css_config.xml).</param>
            <param name="compilerOptions">The string value to be passed directly to the language compiler. </param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CreateCompilerLock(System.String,System.Boolean)">
            <summary>
            Creates the compiler lock object (<see cref="T:System.Threading.Mutex"/>). The Mutex object is now initially owned.
            <para>This object is to be used for the access synchronization to the compiled script file and it can be useful for the 
            tasks like cache purging or explicit script recompilation.</para>
            <para>The optimisticConcurrencyModel has the same meaning as <see cref="T:csscript.Settings.OptimisticConcurrencyModel"/>. 
            And it is to be used to control the concurrency scope.</para>
            </summary>
            <param name="compiledScriptFile">The script file.</param>
            <param name="optimisticConcurrencyModel">if set to <c>true</c> the operation is thread-safe within the current process. 
            Otherwise the operation is thread-safe system wide..</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileWithConfig(System.String,System.String,System.Boolean,csscript.Settings,System.String,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor. Uses script engine settings object and compiler specific options.
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="scriptSettings">The script engine Settings object.</param>
            <param name="compilerOptions">The string value to be passed directly to the language compiler.  </param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadMethod(System.String,System.String[])">
             <summary>
             Surrounds the method implementation code into a class and compiles it code into assembly with CSExecutor and loads it in current AppDomain.
             The most convenient way of using dynamic methods is to declare them as static methods. In this case they can be invoked with wild card character as a class name (e.g. asmHelper.Invoke("*.SayHello")). Otherwise you will need to instantiate class "DyamicClass.Script" in order to call dynamic method.
            
             You can have multiple methods implementations in the single methodCode. Also you can specify namespaces at the begining of the code:
            
             CSScript.LoadMethod(
                 @"using System.Windows.Forms;
            
                 public static void SayHello(string gritting)
                 {
                     MessageBoxSayHello(gritting);
                     ConsoleSayHello(gritting);
                 }
                 public static void MessageBoxSayHello(string gritting)
                 {
                     MessageBox.Show(gritting);
                 }
                 public static void ConsoleSayHello(string gritting)
                 {
                     Console.WriteLine(gritting);
                 }");
             </summary>
             <param name="methodCode">The C# code, containing method implementation.</param>
             <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
             <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadDelegate``1(System.String,System.String,System.Boolean,System.String[])">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns instance of <c>T</c> delegate for the first method in the auto-generated class.</para>
             </summary>
              <example>The following is the simple example of the interface alignment:
             <code>
             var Product = CSScript.LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                     @"int Product(int a, int b)
                                       {
                                           return a * b;
                                       }");
            
             int result = Product(3, 2);
             </code>
             </example>
             <param name="methodCode">The C# code.</param>
             <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
             <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
             <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
             <returns>Instance of <c>T</c> delegate.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadDelegate``1(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns instance of <c>T</c> delegate for the first method in the auto-generated class.</para>
             </summary>
              <example>The following is the simple example of the interface alignment:
             <code>
             var Product = CSScript.LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                     @"int Product(int a, int b)
                                       {
                                           return a * b;
                                       }");
            
             int result = Product(3, 2);
             </code>
             </example>
             <param name="methodCode">The C# code.</param>
             <returns>Instance of <c>T</c> delegate.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.BuildEval(System.String)">
             <summary>
             Evaluates string as a method code and returns the <see cref="T:CSScriptLibrary.MethodDelegate"/>.
             <para><c>BuildEval</c> is a specific case of <see cref="T:CSScriptLibrary.CSScript.LoadMethod"/>, which
             offers a simpler and more convenient syntactical model. It has number of limitations comparing to
             the <see cref="T:CSScriptLibrary.CSScript.LoadMethod"/>.
             <list type="bullet">
                     <item ><description><c>methodCode</c> should contain nothing else but only a single method definition</description></item>
                     <item ><description>The method signature should not contain any return type.</description></item>
                     <item ><description>All namespaces used by the method code should be either specified explicitly in code or listed in the value of <see cref="T:CSSCriptLibrary.CSScript.EvalNamespaces"/>.</description></item>
                     <item ><description>The method code can only interact with the types of the currently loaded in the <c>AppDomain.CurrentDomain</c> assemblies.</description></item>
             </list>
             This is the when the flexibility is partially sacrificed for the sake of convenience.
             <para>The following is a typical example of <c>BuildEval</c> usage:</para>
             <code>
             CSScript.EvalNamespaces = "System;System.Diagnostics";
            
             var Trace = CSScript.BuildEval(@"trace (object message)
                                              {
                                                  Trace.WriteLine(""EVAL:"" + message);
                                              }");
            
             var Average = CSScript.BuildEval("avrg (int a, int b)  { return (a+b)/2.0; }");
            
             Trace(Average(7, 8));
             </code>
             <remarks>Note that CS-Script <c>BuildEval</c> should not be treated as <c>eval</c> in dynamic languages even despite some resemblance. After all C# is a static language.
             <para>CS-Script <c>BuildEval</c> yields the method delegate, which can access all public types of the AppDomain but it cannot interact with the types instances unless
             they are directly passed to the delegate or can be accessed through the Type static members.</para>
             </remarks>
            
            
             </para>
             </summary>
             <param name="methodCode">The method code.</param>
             <returns>Delegate with the "evaluated" routine. It can be invoked as any .NET delegate.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Eval(System.Object[])">
             <summary>
             Evaluates string as a method code and executes it with the specified method parameters.
             <para>
             <c>Eval</c> is very similar to <see cref="T:CSScriptLibrary.CSScript.BuildEval"/> and it shares the some of its limitations.
             <list type="bullet">
                     <item ><description><c>methodCode</c> should contain nothing else but only a single method definition</description></item>
                     <item ><description>The method signature should not contain any return type.</description></item>
                     <item ><description>All namespaces used by the method code should be either specified explicitly in code or listed in the value of <see cref="T:CSSCriptLibrary.CSScript.EvalNamespaces"/>.</description></item>
             </list>
             However <c>Eval</c> offers an important advantage comparing to the <c>BuildEval</c> - after the execution it unloads all dynamically emitted routines
             preventing any potential memory leaks. Though because of this the "evaluated" routines are not reusable thus you need to do the full eval every time
             you wan to invoke the routine. And of course this can affect performance dramatically and that is why usage of <c>Eval</c> should be considered very carefully.
            
             <para>Note that the calling convention is that all parameters of the method to be "evaluated" must be
             followed by the string of code defining this method. </para>
             <para>The following is a typical example of <c>Eval</c> usage:</para>
             <code>
            
             var result = CSScript.Eval(1, 3,
                                      @"sum (int a, int b) {
                                            return a+b;
                                        }");
            
             </code>
            
             <remarks>Note that CS-Script <c>Eval</c> should not be treated as <c>eval</c> in dynamic languages even despite some resemblance.
             After all C# is a static language.
             <para>CS-Script <c>Eval</c> can access all public types of the AppDomain but it cannot interact with the types instances unless
             they are directly passed to the delegate or can be accessed through the Type static members.</para>
             </remarks>
            
            
             </para>
             </summary>
             <param name="args">Collection of the method parameters followed by the method code.</param>
             <returns>The return value of the method being "evaluated"</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadMethod(System.String,System.String,System.Boolean,System.String[])">
             <summary>
             Surrounds the method implementation code into a class and compiles it code into
             assembly with CSExecutor and loads it in current AppDomain. The most convenient way of
             using dynamic methods is to declare them as static methods. In this case they can be
             invoked with wild card character as a class name (e.g. asmHelper.Invoke("*.SayHello")).
             Otherwise you will need to instantiate class "DyamicClass.Script" in order to call dynamic method.
            
            
             You can have multiple methods implementations in the single methodCode. Also you can specify namespaces at the beginning of the code:
             <code>
             CSScript.LoadMethod(
                 @"using System.Windows.Forms;
            
                 public static void SayHello(string gritting)
                 {
                     MessageBoxSayHello(gritting);
                     ConsoleSayHello(gritting);
                 }
                 public static void MessageBoxSayHello(string gritting)
                 {
                     MessageBox.Show(gritting);
                 }
                 public static void ConsoleSayHello(string gritting)
                 {
                     Console.WriteLine(gritting);
                 }");
             </code>
             </summary>
             <param name="methodCode">The C# code, containing method implementation.</param>
             <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
             <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
             <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
             <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCodeFrom(System.String,System.String[])">
            <summary>
            Compiles script code from the specified file into assembly with CSExecutor and loads it in current AppDomain.
            <para>This method is a logical equivalent of the corresponding <c>LoadCode</c> method except the code is
            not specified as a call argument but read from the file instead.</para>
            </summary>
            <param name="scriptFile">The script file.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCodeFrom(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script code from the specified file into assembly with CSExecutor and loads it in current AppDomain.
            <para>This method is a logical equivalent of the corresponding <c>LoadCode</c> method except the code is
            not specified as a call argument but read from the file instead.</para>
            </summary>
            <param name="scriptFile">The script file.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCodeFrom(System.String,System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script code from the specified file into assembly with CSExecutor and loads it in current AppDomain.
            </summary>
            <para>This method is a logical equivalent of the corresponding <c>LoadCode</c> method except the code is
            not specified as a call argument but read from the file instead.</para>
            <param name="scriptFile">The script file.</param>
            <param name="tempFileExtension">The file extension of the temporary file to hold script code during compilation. This parameter may be
            needed if custom CS-Script compilers rely on file extension to identify the script syntax.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCode(System.String,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor and loads it in current AppDomain.
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCode(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor and loads it in current AppDomain.
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCode(System.String,System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor and loads it in current AppDomain.
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="tempFileExtension">The file extension of the temporary file to hold script code during compilation. This parameter may be
            needed if custom CS-Script compilers rely on file extension to identify the script syntax.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Load(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor and loads it in current AppDomain
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled/Loaded assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadWithConfig(System.String,System.String,System.Boolean,csscript.Settings,System.String,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor and loads it in current AppDomain
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="scriptSettings">The script engine Settings object. You can pass null to load <c>CSScript.GlobalSettings</c>. </param>
            <param name="compilerOptions">The string value to be passed directly to the language compiler.  </param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled/Loaded assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Load(System.String)">
            <summary>
            Compiles script file into assembly (temporary file) with CSExecutor and loads it in current AppDomain.
            This method is an equivalent of the CSScript.Load(scriptFile, null, false);
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <returns>Compiled/Loaded assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Load(System.String,System.String[])">
            <summary>
            Compiles script file into assembly (temporary file) with CSExecutor and loads it in current AppDomain.
            This method is an equivalent of the CSScript.Load(scriptFile, null, false);
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled/Loaded assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.DefaultPrint(System.String)">
            <summary>
            Default implementation of displaying application messages.
            </summary>
        </member>
        <member name="F:CSScriptLibrary.CSScript.CacheEnabled">
            <summary>
            Controls if ScriptCache should be used when script file loading is requested (CSScript.Load(...)). If set to true and the script file was previously compiled and already loaded
            the script engine will use that compiled script from the cache instead of compiling it again.
            Note the script cache is always maintained by the script engine. The CacheEnabled property only indicates if the cached script should be used or not when CSScript.Load(...) method is called.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetCachedScriptAssemblyFile(System.String)">
            <summary>
            Returns file path of the cached script assembly matching the script file name.
            </summary>
            <param name="file">Script file path.</param>
            <returns>Path to the previously compiled script assembly.
            Returns null if the cached script cannot be found.
            </returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetLoadedCachedScriptAssembly(System.String)">
            <summary>
            Returns loaded cached script assembly matching the script file name.
            </summary>
            <param name="file">Script file path.</param>
            <returns>Assembly loaded in the current AppDomain.
            Returns null if the loaded script cannot be found.
            </returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetCachedScriptPath(System.String)">
            <summary>
            Returns path to the cached script assembly matching the script file name.
            </summary>
            <param name="scriptFile">Script file path.</param>
            <returns>Cached (compiled) script assembly file path.</returns>
        </member>
        <member name="P:CSScriptLibrary.CSScript.Rethrow">
            <summary>
            Force caught exceptions to be re-thrown.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.AssemblyResolvingEnabled">
             <summary>
             Enables automatic resolving of unsuccessful assembly probing on the base of the Settings.SearchDirs.
             Default value is true.
            
             CLR does assembly probing only in GAC and in the local (with respect to the application) directories. CS-Script
             however allows you to specify extra directory(es) for assembly probing by setting enabling CS-Script assembly resolving
             through setting the AssemblyResolvingEnabled to true and changing the Settings.SearchDirs appropriately.
             </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.ShareHostRefAssemblies">
             <summary>
             Gets or sets the assembly sharing mode. If set to true all assemblies (including the host assembly itself)
             currently loaded to the host application AppDomain are automatically available/accessible from the script code.
             Default value is true.
            
             Sharing the same assembly set between the host application and the script require AssemblyResolvingEnabled to
             be enabled. Whenever SharesHostRefAssemblies is changed to true it automatically sets AssemblyResolvingEnabled to
             true as well.
             </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.KeepCompilingHistory">
            <summary>
            Gets or sets a value indicating whether compiling history should be kept. The compilation results are stored in <see cref="F:CSScriptLibrary.CSScript.CompilingHistory"></see>.
            </summary>
            <value>
            <c>true</c> if compiling history should be kept; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:CSScriptLibrary.CSScript.EvalNamespaces">
             <summary>
             Sets the <c>;</c>-delimited string containing namespaces to be used by the C# expressions being compiled with
             <see cref="T:CSScriptLibrary.CSScript.EvalBuild"/> and <see cref="T:CSScriptLibrary.CSScript.Eval"/>.
             <para>The default value is <c>"System;System.IO;System.Diagnostics;System.Collections.Generic;System.Threading"</c></para>
             </summary>
             <para>The following is a typical example of <c>BuildEval</c> usage:</para>
             <code>
             CSScript.EvalNamespaces = "System;System.Diagnostics";
            
             var Trace = CSScript.BuildEval(@"trace (object message)
                                              {
                                                  Trace.WriteLine(""EVAL:"" + message);
                                              }");
            
             var Average = CSScript.BuildEval("avrg (int a, int b)  { return (a+b)/2.0; }");
            
             Trace(Average(7, 8));
             </code>
             <value>
             The <c>Eval</c> namespaces.
             </value>
        </member>
        <member name="P:CSScriptLibrary.CSScript.ScriptCache">
            <summary>
            Cache of all loaded script files for the current process.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.IsOutOfDateAlgorithm">
            <summary>
            Compiled script probing handler. Analyses the script file and the compiled script (script assembly)
            and determines if the script assembly is out of data and needs to be recompiled.
            <para>The default implementation is <see cref="T:CSScriptLibrary.CSScript.CachProbing.Simplified"/>.</para>
            <para>You can always supply your custom algorithm. For example <p>
            <c>CSScript.IsOutOfDateAlgorithm = (s, a) => true;</c></p>
            fill force CS-Script to recompile the script every time it is loaded.</para>
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.IsOutOfDate">
            <summary>
            Compiled script probing handler. Analyses the script file and the compiled script (script assembly)
            and determines if the script assembly is out of data and needs to be recompiled.
            <para>The default implementation is <see cref="T:CSScriptLibrary.CSScript.CachProbing.Simplified"/>.</para>
            <para>You can always supply your custom algorithm. For example <p>
            <c>CSScript.IsOutOfDate = (s, a) => true;</c></p>
            will force CS-Script to recompile the script every time it is loaded.</para>
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.Evaluator">
            <summary>
            Gets the <see cref="T:CSScriptLibrary.Evaluator"/> instance. This object is to be used for
            dynamic loading of the  C# code by using Mono "compiler as service".
            <para>For the majority of the CS-Script script engine hosting scenarios the Mono compiler
            is a preferred runtime. The major advantage is the compilation speed and superior (comparing to CodeDOM)
            memory management.</para>
            </summary>
            <value>
            The <see cref="T:CSScriptLibrary.Evaluator"/> instance.
            </value>
        </member>
        <member name="T:CSScriptLibrary.CSScript.LoadedScript">
            <summary>
            LoadedScript is a class, which holds information about the script file location and it's compiled and loaded assmbly (current AppDomain).
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadedScript.#ctor(System.String,System.Reflection.Assembly)">
            <summary>
            Creates instance of LoadedScript
            </summary>
            <param name="script">Script file location.</param>
            <param name="asm">Compiled script assembly loaded into current AppDomain.</param>
        </member>
        <member name="F:CSScriptLibrary.CSScript.LoadedScript.script">
            <summary>
            Script file location.
            </summary>
        </member>
        <member name="F:CSScriptLibrary.CSScript.LoadedScript.asm">
            <summary>
            Compiled script assembly loaded into current AppDomain.
            </summary>
        </member>
        <member name="T:CSScriptLibrary.CSScript.CachProbing">
            <summary>
            This class contains default implementations of the <see cref="T:CSScriptLibrary.CSScript.IsOutOfDateAlgorithm"/>.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.CachProbing.Simplified">
            <summary>
            Gets the simplified IsOutOfDateAlgorithm implementation. The implementation is based on analysis of the 'LastWriteTimeUtc' timestamps of the script and compiled script assembly. But not the script dependencies.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.CachProbing.Advanced">
            <summary>
            Gets the comprehensive IsOutOfDateAlgorithm implementation. The implementation is based on analysis of the 'LastWriteTimeUtc' timestamps of the script, compiled script assembly and all script dependencies.
            </summary>
        </member>
        <member name="T:csscript.CSSEnvironment">
            <summary>
            This class implements access to the CS-Script global configuration settings.
            </summary>
        </member>
        <member name="M:csscript.CSSEnvironment.GetCacheDirectory(System.String)">
            <summary>
            Generates the name of the cache directory for the specified script file.
            </summary>
            <param name="file">Script file name.</param>
            <returns>Cache directory name.</returns>
        </member>
        <member name="M:csscript.CSSEnvironment.SaveAsTempScript(System.String)">
            <summary>
            Saves code to the script file in the dedicated CS-Script <c>temporary files</c> location. You do not have to delete the script file after the execution.
            It will be deleted as part of the periodical automatic CS-Script maintenance.
            </summary>
            <param name="content">The script file content.</param>
            <returns>Name of the created temporary script file.</returns>
        </member>
        <member name="M:csscript.CSSEnvironment.GetTempScriptName">
            <summary>
            Generates the script file path in the dedicated CS-Script <c>temporary files</c> location. You do not have to delete such file after the execution.
            It will be deleted as part of the periodical automatic CS-Script maintenance.
            </summary>
            <returns>Name of the temporary script file.</returns>
        </member>
        <member name="M:csscript.CSSEnvironment.SetScriptTempDir(System.String)">
            <summary>
            Sets the location for the CS-Script temporary files directory.
            </summary>
            <param name="path">The path for the temporary directory.</param>
        </member>
        <member name="P:csscript.CSSEnvironment.ScriptFile">
            <summary>
            The full name of the script file being executed.
            </summary>
        </member>
        <member name="P:csscript.CSSEnvironment.PrimaryScriptFile">
            <summary>
            The full name of the primary script file being executed. Usually it is the same file as ScriptFile.
            However these fields are different if analysed from the pre/post-script.
            </summary>
        </member>
        <member name="T:csscript.AppInfo">
            <summary>
            Repository for application specific data
            </summary>
        </member>
        <member name="T:CSScriptLibraryExtensionMethods">
            <summary>
            Method extensions for
            </summary>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetScriptName(System.Reflection.Assembly)">
            <summary>
            Determines whether the specified assembly is a script assembly (compiled script) and returns full path of the script file
            used to compile the assembly. The analysis is based on the fact that script assembly (in hosing scenarios) is always
            stamped with <see cref="T:System.Reflection.AssemblyDescriptionAttribute"/>, which contains name of the script file the
            assembly was compiled from.
            <para>The format of the description </para>
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>
            	Script file path if the specified assembly is a script assembly otherwise <c>null</c>.
            </returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetHelper(System.Reflection.Assembly)">
            <summary>
            Constructs and returns an instance of CSScriptLibrary.AsmHelper class from the underlying Assembly.
            </summary>
            <returns>CSScriptLibrary.AsmHelper</returns>
            <param name="obj">Instance of the type to be extended</param>
            <returns>CSScriptLibrary.AsmHelper</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetStaticMethod(System.Reflection.Assembly,System.String,System.Object[])">
            <summary>
            Returns which emitted delegate based on MethodInfo of the underlying assembly.
            </summary>
            <param name="obj">Instance of the type to be extended</param>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or even *.*).</param>
            <param name="list">List of 'Method' arguments.
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker
            can be obtained as following:
            <para>
            GetStaticMethod("Calc.Sum", 0, 0)
            </para>
            You can pass any integer as the second and third parameter because it will be used only to obtain the
            information about the parameter type (in this case System.Int32).</param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetStaticMethodWithArgs(System.Reflection.Assembly,System.String,System.Type[])">
            <summary>
            Returns which emitted delegate based on MethodInfo of the underlying assembly.
            </summary>
            <param name="obj">Instance of the type to be extended</param>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or even *.*).</param>
            <param name="list">List of 'Method' arguments.</param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetStaticMethod(System.Reflection.Assembly)">
             <summary>
             <param name="obj">Instance of the type to be extended</param>
             Specialised version of GetMethodInvoker which returns MethodDelegate of the very first method found in the
             underlying assembly. This method is an overloaded implementation of the GetStaticMethod(string methodName, params object[] list).
            
             Use this method when script assembly contains only one single type with one method.
             </summary>
             <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.TryCreateObject(System.Reflection.Assembly,System.String)">
             <summary>
             Attempts to create instance of a class from underlying assembly.
             </summary>
             <param name="obj">Instance of the type to be extended</param>
             <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            
             You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
             <returns>Instance of the 'Type'. Returns null if the instance cannot be created.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.CreateObject(System.Reflection.Assembly,System.String)">
            <summary>
            Creates instance of a class from underlying assembly.
            </summary>
            <param name="obj">Instance of the type to be extended</param>
            <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
            <returns>Instance of the 'Type'. Throws an ApplicationException if the instance cannot be created.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.ExtendLife(System.MarshalByRefObject,System.TimeSpan)">
            <summary>
            Extends the life of the instance created in the remote AppDomain.
            </summary>
            <param name="obj">The instance created in the remote AppDomain.</param>
            <param name="renewalTime">The renewal time.</param>
            <returns>Returns <see cref="T:System.Runtime.Remoting.LifetimeClientSponsor" />  object.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.ExtendLifeFromMinutes(System.MarshalByRefObject,System.Int32)">
            <summary>
            Extends the life of the instance created in the remote AppDomain.
            </summary>
            <param name="obj">The instance created in the remote AppDomain.</param>
            <param name="minutes">The renewal time in minutes.</param>
            <returns>Returns <see cref="T:System.Runtime.Remoting.LifetimeClientSponsor" />  object.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.TryAlignToInterface``1(System.Object)">
            <summary>
            Attempts to align (pseudo typecast) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <returns>Interface object or <c>null</c> if alignment was unsuccessful.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.TryAlignToInterface``1(System.Object,System.Boolean)">
            <summary>
            Attempts to align (pseudo typecast) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="useAppDomainAssemblies">If set to <c>true</c> uses all loaded assemblies of the current <see cref="T:System.AppDomain"/>
            when emitting (compiling) aligned proxy object.</param>
            <returns>Interface object or <c>null</c> if alignment was unsuccessful.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.TryAlignToInterface``1(System.Object,System.String[])">
            <summary>
            Attempts to align (pseudo typecast) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional dependency
            assemblies the interface depends in. </param>
            <returns>Interface object or <c>null</c> if alignment was unsuccessful.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.TryAlignToInterface``1(System.Object,System.Boolean,System.String[])">
            <summary>
            Attempts to align (pseudo typecast) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="useAppDomainAssemblies">If set to <c>true</c> uses all loaded assemblies of the current <see cref="T:System.AppDomain"/>
            when emitting (compiling) aligned proxy object.</param>
            <param name="refAssemblies">The string array containing file names to the additional dependency
            assemblies the interface depends in. </param>
            <returns>Interface object or <c>null</c> if alignment was unsuccessful.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.AlignToInterface``1(System.Object,System.Boolean)">
            <summary>
            Aligns (pseudo typecasts) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="useAppDomainAssemblies">If set to <c>true</c> uses all non-GAC loaded assemblies of the current <see cref="T:System.AppDomain"/>
            when emitting (compiling) aligned proxy object.</param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.AlignToInterface``1(System.Object,System.String[])">
            <summary>
            Aligns (pseudo typecasts) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="refAssemblies">The string array containing file names to the additional dependency
            assemblies the interface depends in. </param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.AlignToInterface``1(System.Object,System.Boolean,System.String[])">
            <summary>
            Aligns (pseudo typecasts) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="useAppDomainAssemblies">If set to <c>true</c> uses all non-GAC loaded assemblies of the current <see cref="T:System.AppDomain"/>
            when emitting (compiling) aligned proxy object.</param>
            <param name="refAssemblies">The string array containing file names to the additional dependency
            assemblies the interface depends in. </param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.AlignToInterface``1(System.Object)">
            <summary>
            Aligns (pseudo typecasts) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <returns>Interface object.</returns>
        </member>
        <member name="T:CSScriptLibrary.FastInvokeDelegate">
             <summary>
             Delegate which is used as a return type for AsmHelper.GetMethodInvoker().
            
             AsmHelper.GetMethodInvoker() allows obtaining dynamic method delegate emitted on the base of the MethodInfo (from the compiled script type).
             </summary>
             <param name="instance">Instance of the type which method is to be invoked.</param>
             <param name="paramters">Optional method parameters.</param>
             <returns>Returns MethodInfo return value</returns>
        </member>
        <member name="T:CSScriptLibrary.MethodDelegate">
             <summary>
             Delegate which is used as a return type for AsmHelper.GetMethodInvoker().
            
             AsmHelper.GetStaticMethod() and AsmHelper.GetMethod() allow obtaining dynamic method delegate emitted on the base of the MethodInfo (from the compiled script type).
             </summary>
             <param name="paramters">Optional method parameters.</param>
             <returns>Returns MethodInfo return value</returns>
        </member>
        <member name="T:CSScriptLibrary.AsmHelper">
            <summary>
            Helper class to simplify working with dynamically loaded assemblies.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.AlignToInterface``1(System.Object)">
            <summary>
            Aligns (pseudo typecasts) object to the specified interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            <remarks>
            The important difference between this method being called from <see cref="T:CSScriptLibrary.AsmHelper"/> working
            with the assembly in current and remote <see cref="T:System.AppDomain"/> is that is that the actual
            interface alignment is performed in the corresponding <see cref="T:System.AppDomain"/>.
            </remarks>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.AlignToInterface``1(System.Object,System.String[])">
            <summary>
            Aligns (pseudo typecasts) object to the specified interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            <remarks>
            The important difference between this method being called from <see cref="T:CSScriptLibrary.AsmHelper"/> working
            with the assembly in current and remote <see cref="T:System.AppDomain"/> is that is that the actual
            interface alignment is performed in the corresponding <see cref="T:System.AppDomain"/>.
            </remarks>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional dependency
            assemblies the interface depends in. </param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.AlignToInterface``1(System.Object,System.Boolean)">
            <summary>
            Aligns (pseudo typecasts) object to the specified interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            <remarks>
            The important difference between this method being called from <see cref="T:CSScriptLibrary.AsmHelper"/> working
            with the assembly in current and remote <see cref="T:System.AppDomain"/> is that is that the actual
            interface alignment is performed in the corresponding <see cref="T:System.AppDomain"/>.
            </remarks>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="useAppDomainAssemblies">If set to <c>true</c> uses all loaded assemblies of the current <see cref="T:System.AppDomain"/></param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.CreateAndAlignToInterface``1(System.String)">
            <summary>
            Creates object in remote or current <see cref="T:System.AppDomain"/> and aligns (pseudo typecasts) it to the specified interface.
            <para>Semantically it is an equivalent of calling
            <code>asmHelper.AlignToInterface(asmHelper.CreateObject(typeName))</code>
            </para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetMethodInvoker(System.String,System.Object[])">
            <summary>
            This method returns extremely fast delegate for the method specified by "methodName" and
            method arguments "list". Invoking such delegate is ~100 times faster than invoking with pure reflection
            (MethodInfo.Invoke()).
            </summary>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowd to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments.
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker
            can be obtained as following:
            <para></para>
            GetMethodInvoker("Calc.Sum", 0, 0)
            <para></para>
            You can pass any integer as the second and third parameter because it will be used only to obtain the
            information about the parameter type (in this case System.Int32).</param>
            <returns>Returns delegate of CSScriptLibrary.FastInvokeDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetStaticMethod(System.String,System.Object[])">
            <summary>
            Specialised version of GetMethodInvoker which returns MethodDelegate thus you do not need to specify
            object instance (null) when calling static methods.
            </summary>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments. </param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
            <remarks>
            <para>
            <para>
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker
            can be obtained as following:
            </para>
            </para>
            <example>
            <code>GetStaticMethod("Calc.Sum", 0, 0)</code>
            </example>
            <para>
            You can pass any integer as the second and third parameter because it will be used only to obtain the
            information about the parameter type (in this case System.Int32).
            </para>
            </remarks>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetStaticMethodWithArgs(System.String,System.Type[])">
            <summary>
            Specialised version of GetMethodInvoker which returns MethodDelegate thus you do not need to specify
            object instance (null) when calling static methods.
            </summary>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments. </param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetStaticMethod">
            <summary>
            Specialised version of GetMethodInvoker which returns MethodDelegate of the very first method found in the
            underlying assembly. This method is an overloaded implementation of the GetStaticMethod(string methodName, params object[] list).
            <para>
            Use this method when script assembly contains only one single type with one method.
            </para>
            </summary>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetMethod(System.Object,System.String,System.Object[])">
            <summary>
            Specialized version of GetMethodInvoker which returns MethodDelegate thus you do not need to specify
            object instance when calling instance methods as delegate will maintain the instance object internally.
            </summary>
            <param name="instance">Instance of the type, which implements method is to be wrapped by MethodDelegate.</param>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowed to use wild
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments.
            <para>
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker
            can be obtained as following:
            <code>
            GetMethod(instance, "Sum", 0, 0)
            </code>
            You can pass any integer as the second and third parameter because it will be used only to obtain the
            information about the parameter type (in this case System.Int32).
            </para>
            </param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.#ctor(System.Reflection.Assembly)">
            <summary>
            Creates an instance of AsmHelper for working with assembly dynamically loaded to current AppDomain.
            Calling "Dispose" is optional for "current AppDomain"scenario as no new AppDomain will be ever created.
            </summary>
            <param name="asm">Assembly object.</param>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Creates an instance of AsmHelper for working with assembly dynamically loaded to non-current AppDomain.
            This method initialises instance and creates new ('remote') AppDomain with 'domainName' name. New AppDomain is automatically unloaded as result of "disposable" behaviour of AsmHelper.
            </summary>
            <param name="asmFile">File name of the assembly to be loaded.</param>
            <param name="domainName">Name of the domain to be created.</param>
            <param name="deleteOnExit">'true' if assembly file should be deleted when new AppDomain is unloaded; otherwise, 'false'.</param>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Invoke(System.String,System.Object[])">
            <summary>
            Executes static method of the underlying assembly.
            </summary>
            <param name="methodName">'Method' name including 'Type' name (e.g. MyType.DoJob). It is allowed to use wild card character
            to indicate that the Type name of the method is irrelevant (e.g. "*.Method").</param>
            <param name="list">List of 'Method' arguments.</param>
            <returns>Returns object of the same type as 'Method' return type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.InvokeInst(System.Object,System.String,System.Object[])">
            <summary>
            Executes an instance method of the underlying assembly.
            </summary>
            <param name="obj">Instance of the object whose method is to be invoked.</param>
            <param name="methodName">'Method' name (excluding 'Type' name). It is allowed to use wild card character
            to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or even "*.*").</param>
            <param name="list">List of 'Method' arguments.</param>
            <returns>Returns object of the same type as 'Method' return type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.TryCreateObject(System.String)">
             <summary>
             Attempts to create instance of a class from underlying assembly.
             </summary>
             <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            
             You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
             <returns>Instance of the 'Type'. Returns null if the instance cannot be created.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.CreateObject(System.String)">
            <summary>
            Creates instance of a class from underlying assembly.
            </summary>
            <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
            <returns>Instance of the 'Type'. Throws an ApplicationException if the instance cannot be created.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Unload">
            <summary>
            Unloads 'remote' AppDomain if it was created.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Dispose">
            <summary>
            Implementation of IDisposable.Dispose(). Disposes allocated exetrnal resources if any. Call this method to unload non-current AppDomain (if it was created).
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Dispose(System.Boolean)">
            <summary>
            Actual implementation of IDisposable.Dispose()
            </summary>
            <param name="disposing">'false' if the method has been called by the runtime from inside the finalizer ; otherwise, 'true'.</param>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Finalize">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="P:CSScriptLibrary.AsmHelper.ScriptExecutionDomain">
            <summary>
            Instance of the AppDomain, which is used to execute the script.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.AsmHelper.RemoteObject">
            <summary>
            Reference to the <see cref="T:CSScriptLibrary.AsmHelper"/> "worker" object created in the remote AppDomain. This property is null
            unless <see cref="T:CSScriptLibrary.AsmHelper"/> was instantiated for the <c>remote execution</c> scenario.
            <para>This property can be useful when you need to access the remote object in order to manage the "life time" of the AsmHelper in
            Remoting and WCF scenarios.</para>
            </summary>
            <example>
            <code>
            var scriptHelper = new AsmHelper(scriptAsmFile, null, true);
            scriptHelper.RemoteObject.ExtendLifeFromMinutes(30);
            </code>
            </example>
        </member>
        <member name="P:CSScriptLibrary.AsmHelper.CachingEnabled">
            <summary>
            Flag that indicates if method caching is enabled. It is set to true by default.
            <para></para>
            When caching is enabled AsmHelper generates (emits) extremely fast delegates for
            the methods being invoked. If AsmHelper is in cache mode it performs more than twice faster.
            However generation of the delegate does take some time that is why you may consider
            switching caching off if the method is to be invoked only once.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.AsmHelper.ProbingDirs">
             <summary>
            Array of directories to be used for assembly probing.
             </summary>
        </member>
        <member name="T:CSScriptLibrary.IAsmBrowser">
            <summary>
            Defines method for calling assembly methods and instantiating assembly types.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AsmBrowser.CreateInstance(System.String)">
            <summary>
            Creates instance of a Type from underlying assembly.
            </summary>
            <param name="typeName">Name of the type to be instantiated. Allows wild card character (e.g. *.MyClass can be used to instantiate MyNamespace.MyClass).</param>
            <returns>Created instance of the type.</returns>
        </member>
        <member name="T:CSScriptLibrary.FastInvoker">
             <summary>
             Class which is capable of emitting the dynamic method delegate based on the MethodInfo. Such delegate is
             extremely fast and it can demonstrate up to 100 times better performance comparing to the pure
             Reflection method invokation (MethodInfo.Invoke()).
            
            
             Based on http://www.codeproject.com/KB/cs/FastInvokerWrapper.aspx
             </summary>
        </member>
        <member name="F:CSScriptLibrary.FastInvoker.info">
            <summary>
            MethodInfo instance which was used to generate dynamic method delegate.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.FastInvoker.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Constructor
            </summary>
            <param name="info">MethodInfo instance which is to be used to generate dynamic method delegate.</param>
        </member>
        <member name="M:CSScriptLibrary.FastInvoker.Invoke(System.Object,System.Object[])">
            <summary>
            Invokes dynamic method delegate generated from the MethodInfo object.
            </summary>
            <param name="instance">Instance of the type which method is to be invoked.</param>
            <param name="paramters">Optional method parameters.</param>
            <returns>Invokes dynamic method delegate return value</returns>
        </member>
        <member name="M:CSScriptLibrary.FastInvoker.GetMethodInvoker">
            <summary>
            Returns dynamic method delegate generated from the MethodInfo object.
            </summary>
            <returns>FastInvokeDelegate instance.</returns>
        </member>
        <member name="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1">
            <summary>
                A utility class which converts an object to specified interface T. The object does
                not necessarily need to implement the interface formally.
            </summary>
            <typeparam name="T">Interface definition to convert to.</typeparam>
            <remarks>
            <para>
                Class Information:
                <list type="bullet">
                    <item name="authors">Authors: Ruben Hakopian</item>
                    <item name="date">March 2009</item>
                    <item name="originalURL">http://rubenhak.com/?p=167</item>
                </list>
            </para>
            </remarks>
        </member>
        <member name="F:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1._proxyCache">
            <summary>
            Represents a map from a object type to the type of its proxy class.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.As(System.Object,System.String[])">
            <summary>
            Converts specified object to an another object which implements interface T.
            </summary>
            <param name="o">The object to convert.</param>
            <param name="refAssemblies">The string array containing file names to the additional dependency assemblies
            the interface depends in. </param>
            <returns>Converted object if succeeded; null otherwise.</returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.CheckSourceObject(System.Type,System.Type,System.String[])">
            <summary>
            Checks if the source type can be convert to destination interface type.
            </summary>
            <param name="interfaceType">The source type to convert from.</param>
            <param name="sourceType">The destination interface type to convert to.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional dependency assemblies
            the interface depends in. </param>
            <returns>true if conversion can be performed; false otherwise</returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.CastToInterface(System.Type,System.Object,System.String[])">
            <summary>
            Creates an instance of an proxy object which implements interface T and wraps specified object.
            </summary>
            <param name="interfaceType">Type of the interface.</param>
            <param name="o">The object to convert.</param>
            <param name="refAssemblies">The string array containing file names to the additional dependency assemblies
            the interface depends in. </param>
            <returns>Instance of the proxy object.</returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.BuildProxyClass(System.Type,System.Type,System.String[])">
            <summary>
            Builds the proxy class for specified interface and source types.
            </summary>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional dependency assemblies
            the interface depends in. </param>
            <returns>Type definition for proxy class.</returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.BuildProxyClassCode(System.Type,System.Type,System.String@)">
            <summary>
            Added by Oleg Shilo
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.GenerateProxyClass(System.Type,System.Type)">
            <summary>
            Generates the proxy class.
            </summary>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.GenerateProxyClassProperties(System.CodeDom.CodeTypeDeclaration,System.Type,System.Type)">
            <summary>
            Generates the proxy class properties.
            </summary>
            <param name="genClass">The generated class.</param>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.GenerateProxyClassMethods(System.CodeDom.CodeTypeDeclaration,System.Type,System.Type)">
            <summary>
            Generates the proxy class methods.
            </summary>
            <param name="genClass">The generated class.</param>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.GenerateProxyClassEvents(System.CodeDom.CodeTypeDeclaration,System.CodeDom.CodeConstructor,System.Type,System.Type)">
            <summary>
            Generates the proxy class events.
            </summary>
            <param name="genClass">The generated class.</param>
            <param name="constructor">The generated class constructor.</param>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
        </member>
        <member name="T:CSScriptLibrary.DomainAssemblies">
            <summary>
            Type of the assemblies to be loaded/referenced.
            </summary>
        </member>
        <member name="F:CSScriptLibrary.DomainAssemblies.None">
            <summary>
            No assemblies
            </summary>
        </member>
        <member name="F:CSScriptLibrary.DomainAssemblies.AllStatic">
            <summary>
            All static current AppDomain assemblies
            </summary>
        </member>
        <member name="F:CSScriptLibrary.DomainAssemblies.AllStaticNonGAC">
            <summary>
            All static and non-GAC current AppDomain assemblies
            </summary>
        </member>
        <member name="F:CSScriptLibrary.DomainAssemblies.All">
            <summary>
            All current AppDomain assemblies
            </summary>
        </member>
        <member name="T:CSScriptLibrary.BuildConfiguration">
            <summary>
            Type of the build (compile) configuration
            </summary>
        </member>
        <member name="F:CSScriptLibrary.BuildConfiguration.Debug">
            <summary>
            The typical Debug build configuration
            </summary>
        </member>
        <member name="F:CSScriptLibrary.BuildConfiguration.Release">
            <summary>
            The typical Release build configuration
            </summary>
        </member>
        <member name="T:CSScriptLibrary.Evaluator">
            <summary>
            A wrapper class that encapsulates the functionality of the Mono.CSharp.Evaluator.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CSScriptLibrary.Evaluator"/> class.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.Reset(System.Boolean)">
            <summary>
            Resets Evaluator.
            <para>
            The <see cref="T:Mono.CSharp.CompilerSettings"/> and <see cref="P:CSScriptLibrary.Evaluator.CompilingResult"/> are reinitialized.
            All reference assemblies are also cleared.
            </para>
            <para>Optionally the default current AppDomain assemblies can be referenced automatically.</para>
            </summary>
            <param name="referenceDomainAssemblies">if set to <c>true</c> the default assemblies of the current AppDomain
            will be referenced (see <see cref="M:CSScriptLibrary.Evaluator.ReferenceDomainAssemblies(CSScriptLibrary.DomainAssemblies)"/> method).
            </param>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.ReferenceDomainAssemblies(CSScriptLibrary.DomainAssemblies)">
            <summary>
            References the domain assemblies.
            </summary>
            <param name="assemblies">The type of assemblies to be referenced.</param>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.ReferenceAssembly(System.String)">
            <summary>
            References the assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="assembly">The path to the assembly file.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.Evluator"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.ReferenceAssembly(System.Reflection.Assembly)">
            <summary>
            References the assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="assembly">The assembly instance.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.Evluator"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.ReferenceAssemblyByName(System.String)">
            <summary>
            References the name of the assembly by its partial name.
            <para>Note that the referenced assembly will be loaded into the host AppDomain in order to resolve assembly partial name.</para>
            <para>It is an equivalent of <code>Evaluator.ReferenceAssembly(Assembly.LoadWithPartialName(assemblyPartialName))</code></para>
            </summary>
            <param name="assemblyPartialName">Partial name of the assembly.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.Evluator"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.ReferenceAssemblyOf(System.Object)">
            <summary>
            References the assembly by the object, which belongs to this assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="obj">The object, which belongs to the assembly to be referenced.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.Evluator"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.ReferenceAssemblyByNamespace(System.String)">
            <summary>
            References the assembly by the namespace it implements.
            </summary>
            <param name="namespace">The namespace.</param>
            <returns><c>true</c> if namespace was successfully resolved and
            the reference was added; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.ReferenceAssembliesFromCode(System.String,System.String[])">
            <summary>
            References the assemblies from the script code.
            </summary>
            <param name="code">The script code.</param>
            <param name="searchDirs">The assembly search/probing directories.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.Evluator"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.ReferenceAssemblyOf``1">
            <summary>
            References the assembly by the object, which belongs to this assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <typeparam name="T">Te type which is implemented in the assembly to be referenced.</typeparam>
            <returns>The instance of the <see cref="T:CSScriptLibrary.Evluator"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.LoadCode(System.String)">
             <summary>
             Evaluates C# code and loads (returns instance) the first class defined in the code to the current AppDomain.
             </summary>
             <example>The following is the simple example of the LoadCode usage:
            <code>
             dynamic script = CSScript.Evaluator
                                      .LoadCode(@"using System;
                                                  public class Script
                                                  {
                                                      public int Sum(int a, int b)
                                                      {
                                                          return a+b;
                                                      }
                                                  }");
             int result = script.Sum(1, 2);
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <returns>Instance of the class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.LoadFile(System.String)">
             <summary>
             Evaluates C# file from the specified file and loads (returns instance) the first class defined in the script file
             to the current AppDomain.
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             dynamic script = CSScript.Evaluator
                                      .LoadFile("calc.cs");
             int result = script.Sum(1, 2);
             </code>
             </example>/// <param name="scriptFile">The C# script file.</param>
             <returns>Instance of the class defined in the script file.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.LoadCode``1(System.String)">
             <summary>
             Evaluates C# code and loads (returns instance) the first class defined in the code to the current AppDomain.
             After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
             <para><c>Note:</c> the script class does not have to inherit from the <c>T</c> parameter as the proxy type
             will be generated anyway.</para>
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             public interface ICalc
             {
                 int Sum(int a, int b);
             }
             ....
             ICalc calc = CSScript.Evaluator
                                  .LoadCode&lt;ICalc&gt;(@"using System;
                                                     public class Script
                                                     {
                                                         public int Sum(int a, int b)
                                                         {
                                                             return a+b;
                                                         }
                                                     }");
             int result = calc.Sum(1, 2);
             </code>
             </example>
             <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
             <param name="scriptText">The C# script text.</param>
             <returns>Aligned to the <c>T</c> interface instance of the class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.GetReferencedAssemblies(System.String,System.String[])">
            <summary>
            Gets referenced assemblies from the script code.
            </summary>
            <param name="code">The script code.</param>
            <param name="searchDirs">The assembly search/probing directories.</param>
            <returns>Array of the referenced assemblies</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.LoadFile``1(System.String)">
             <summary>
             Evaluates C# file and loads (returns instance) the first class defined in the script file to the current AppDomain.
             After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
             <para><c>Note:</c> the script class does not have to inherit from the <c>T</c> parameter as the proxy type
             will be generated anyway.</para>
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             public interface ICalc
             {
                 int Sum(int a, int b);
             }
             ....
             ICalc calc = CSScript.Evaluator
                                  .LoadFile&lt;ICalc&gt;("calc.cs");
             int result = calc.Sum(1, 2);
             </code>
             </example>
             <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
             <param name="scriptFile">The C# script text.</param>
             <returns>Aligned to the <c>T</c> interface instance of the class defined in the script file.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.LoadMethod(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it and loads (returns instance) the class to the current AppDomain.
             </summary>
             <example>The following is the simple example of the LoadMethod usage:
             <code>
             dynamic script = CSScript.Evaluator
                                      .LoadMethod(@"int Product(int a, int b)
                                                    {
                                                        return a * b;
                                                    }");
            
             int result = script.Product(3, 2);
             </code>
             </example>
             <param name="code">The C# script text.</param>
             <returns>Instance of the first class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.LoadMethod``1(System.String)">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it and loads (returns instance) the class to the current AppDomain.
            <para>
            After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
            </para>
            </summary>
            <example>The following is the simple example of the interface alignment:
            <code>
            public interface ICalc
            {
                int Sum(int a, int b);
                int Div(int a, int b);
            }
            ....
            ICalc script = CSScript.Evaluator
                                   .LoadMethode&lt;ICalc&gt;(@"public int Sum(int a, int b)
                                                         {
                                                             return a + b;
                                                         }
                                                         public int Div(int a, int b)
                                                         {
                                                             return a/b;
                                                         }");
            int result = script.Div(15, 3);
            </code>
            </example>
            <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
            <param name="code">The C# script text.</param>
            <returns>Aligned to the <c>T</c> interface instance of the auto-generated class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.CreateDelegate(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns instance of <c>T</c> delegate for the first method in the auto-generated class.</para>
             </summary>
              <example>The following is the simple example of the interface alignment:
             <code>
             var Product = CSScript.Evaluator.LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                             @"int Product(int a, int b)
                                               {
                                                   return a * b;
                                               }");
            
             int result = Product(3, 2);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns>Instance of <c>T</c> delegate.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.LoadDelegate``1(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns <see cref="T:CSScriptLibrary.MethodDelegate"/> for class-less style of invoking.</para>
             </summary>
              <example>The following is the simple example of the interface alignment:
             <code>
             var Product = CSScript.Evaluator
                                   .CreateDelegate(@"int Product(int a, int b)
                                                     {
                                                         return a * b;
                                                     }");
            
             int result = (int)Product(3, 2);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.CompileMethod(System.String)">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>Scripting.DynamicClass</c>), evaluates it.
            <para>
            Returns instance of the <see cref="T:CSScriptLibrary.Evluator"/> for further access to the compilation result.</para>
            </summary>
            <param name="code">The C# code.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.Evluator"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.GetCompiledAssembly">
            <summary>
            Gets the assembly compiled with the last Compile*/Load* call.
            </summary>
            <returns>Instance of the <see cref="T:System:Reflection.Assembly"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.GetCompiledType(System.String)">
            <summary>
            Gets a type from the last Compile/Evaluate/Load call.
            </summary>
            <param name="type">The type name.</param>
            <returns>The type instance</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.CompileCode(System.String)">
            <summary>
            Evaluates (compiles) C# code.
            </summary>
            <param name="scriptText">The C# script text.</param>
            <returns>The instance of the <see cref="T:CSScriptLibrary.Evluator"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.Evaluate(System.String)">
            <summary>
            Evaluates the specified C# statement and returns the result of the execution.
            </summary>
            <example>
            <code>
            string upperCaseText = (string)CSScript.Evaluator.Evaluate("\"Hello\".ToUpper();");
            int sum = (int)CSScript.Evaluator.Evaluate("1+2;");
            </code>
            </example>
            <param name="scriptText">The C# statement.</param>
            <returns>Result of the evaluation (execution).</returns>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.Run(System.String)">
            <summary>
            Evaluates the specified C# statement. The statement must be "void" (returning no result).
            </summary>
            <example>
            <code>
            CSScript.Evaluator.Run("using System;");
            CSScript.Evaluator.Run("Console.WriteLine(\"Hello World!\");");
            </code>
            </example>
            <param name="scriptText">The C# statement.</param>
        </member>
        <member name="M:CSScriptLibrary.Evaluator.GetService">
            <summary>
            Gets the underlying <see cref="T:Mono.CSharp.Evaluator"/>.It is the actual Mono "compiler as service".
            </summary>
            <returns>Instance of <see cref="T:Mono.CSharp.Evaluator"/>.</returns>
        </member>
        <member name="P:CSScriptLibrary.Evaluator.CompilerSettings">
            <summary>
            Gets or sets the compiler settings.
            </summary>
            <value>The compiler settings.</value>
        </member>
        <member name="P:CSScriptLibrary.Evaluator.CompilingResult">
            <summary>
            Gets or sets the compiling result.
            </summary>
            <value>The compiling result.</value>
        </member>
        <member name="P:CSScriptLibrary.Evaluator.ThrowOnError">
            <summary>
            Gets or sets the flag indicating if the compilation error should throw an exception.
            </summary>
            <value>The throw on error.</value>
        </member>
        <member name="P:CSScriptLibrary.Evaluator.WarningsAsErrors">
            <summary>
            Gets or sets the warnings as errors.
            </summary>
            <value>The warnings as errors.</value>
        </member>
        <member name="P:CSScriptLibrary.Evaluator.IsDebugSymbolDefined">
            <summary>
            Gets or sets the flag for defining the conditional compiling symbol "DEBUG".
            </summary>
            <value>The flag indicating if the "DEBUG" symbol defined.</value>
        </member>
        <member name="P:CSScriptLibrary.Evaluator.Configuration">
            <summary>
            Gets or sets the build configuration.
            </summary>
            <value>The configuration value.</value>
        </member>
        <member name="P:CSScriptLibrary.Evaluator.IsTraceSymbolDefined">
            <summary>
            Gets or sets the flag for defining the conditional compiling symbol "TRACE".
            </summary>
            <value>The flag indicating if the "TRACE" symbol defined.</value>
        </member>
        <member name="T:CSScriptLibrary.CompilingResult">
            <summary>
            Custom implementation of <see cref="T:Mono.CSharp.ReportPrinter"/> required by
            <see cref="T:Mono.CSharp"/> API model for handling (reporting) compilation errors.
            <para><see cref="T:Mono.CSharp"/> default compiling error reporting (e.g. <see cref="T:Mono.CSharp.ConsoleReportPrinter"/>)
            is not dev-friendly, thus <c>CompilingResult</c> is acting as an adapter bringing the Mono API close to the
            traditional CodeDOM error reporting model.</para>
            </summary>
        </member>
        <member name="F:CSScriptLibrary.CompilingResult.Errors">
            <summary>
            The collection of compiling errors.
            </summary>
        </member>
        <member name="F:CSScriptLibrary.CompilingResult.Warnings">
            <summary>
            The collection of compiling warnings.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CompilingResult.CreateException(System.Boolean)">
            <summary>
            Creates the <see cref="T:System.Exception"/> containing combined error information.
            Optionally warnings can also be included in the exception info.
            </summary>
            <param name="hideCompilerWarnings">The flag indicating if compiler warnings should be included in the error (<see cref="T:System.Exception"/>) info.</param>
            <returns>Instance of the <see cref="T:csscript.CompilerException"/>.</returns>
        </member>
        <member name="M:CSScriptLibrary.CompilingResult.Reset">
            <summary>
            Clears all errors and warnings.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CompilingResult.Print(Mono.CSharp.AbstractMessage,System.Boolean)">
            <summary>
            Handles compilation event message.
            </summary>
            <param name="msg">The compilation event message.</param>
            <param name="showFullPath">if set to <c>true</c> [show full path].</param>
        </member>
        <member name="P:CSScriptLibrary.CompilingResult.HasErrors">
            <summary>
            Indicates if the last compilation yielded any errors.
            </summary>
            <value>If set to <c>true</c> indicates presence of compilation error(s).</value>
        </member>
        <member name="P:CSScriptLibrary.CompilingResult.HasWarnings">
            <summary>
            Indicates if the last compilation yielded any warnings.
            </summary>
            <value>If set to <c>true</c> indicates presence of compilation warning(s).</value>
        </member>
    </members>
</doc>
